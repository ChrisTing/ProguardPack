apply plugin: 'com.android.application'
/*
定义一个方法，仅def声明时，返回类型任意(自动判断)
   可以将返回值直接写成String 或def String
gradle支持groovy语言，groovy默认引入的包有：
  java.io.*;
  java.lang.*;
  java.math.BigDecimal;
  java.math.BigInteger;
  java.net.*;
  java.util.*;
  groovy.lang.*;
  groovy.util.*;
 */

def appName() {
    return "ProguardPack"
}

def String vName() {
    return "1.1"
}

def buildTime() {
//    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"));
    return new Date().format('MMdd', TimeZone.getTimeZone('GMT+08:00'))
}

//获取项目最新一次git commit的SHA值,记得要把git要作为环境变量
//def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim() //git-v2.12 not support
def gitSha() {//git-v2.12 support
    'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()
}

/*
Build Tasks:
    General Tasks:
        assemble
        The task to assemble the output(s) of the project 用于输出build目录  输出的apk文件为buildType和productflavor的组合体
            还可以使用 assembleBuildType,如$gradle assembleAabbcc 只执行这一个buildType的输出
        check
        The task to run all the checks.  运行检测，会执行test任务
        build
        This task does both assemble and check 包含assemble和check task
        clean
        This task cleans the output of the project 清除输出的build目录
 */




android {
//    compileSdkVersion 22
//    buildToolsVersion "22.0.1"
    compileSdkVersion rootProject.ext.compileSdkVersion  //使用project>build.gradle#ext
    buildToolsVersion rootProject.ext.buildToolsVersion

    lintOptions {
        abortOnError false  //lint 错误是否要中断运行
    }

    sourceSets {
        main {
            java {
                srcDir 'src/java'
            }
            resources {
                srcDir 'src/resources'
            }
        }
//        main.jniLibs {//注意DSL中，property可以用圆点，method可以用 {}
//            srcDir('libs')
//        } //所以可以写成  main {jniLibs{srcDir()}} 或 main.jniLibs.srcDir()
//        main.jniLibs.srcDir('libs')
        //若有多个目录  jniLibs.srcDirs=['libs', 'x86libs']

    }

    defaultConfig {
        applicationId "com.stone.myapplication"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        //versionCode 是一个int值，区间为[0,99999] 一般用于判断app升级
        versionCode 1
        //versionName 是一个字符串，可以展示给用户
        versionName vName() //使用外部定义的方法
        /*
        manifestPlaceholders 
        	manifest中使用占位符，如：<... android:name="${YOUR_APP_KEY}" >
        	以[key-value]形式替换：[YOUR_APP_KEY:"value"]
        */
        manifestPlaceholders = [YOUR_APP_KEY: "后台的appkey"]
        // Enabling multidex support.  method count > 65536    可能还需要其他的操作，现在的新版可能不用(自行试验)
        multiDexEnabled true

        //AS3.0  新增
        flavorDimensions "debug", "release"//, "aabbcc"

    }
    defaultConfig.manifestPlaceholders = [YOUR_APP_KEY: "后台的appkey-hoho"]  //reset

    signingConfigs { //gradle assembleRelease
        /*
           可以定义多个签名配置项，如下面的myConfig
         */
        myConfig {
            storeFile file("stone.keystore")
            storePassword "482935"   //修改成自己的签名文件store密码
//			storePassword System.console().readLine("\nKeystore password: ")  //使用命令行gradle build 编译
            keyAlias "stone"
            keyPassword "482935"  //修改成自己的签名文件key密码
//			keyPassword System.console().readLine("\nKey password: ") //使用命令行gradle build 编译
        }
    }

    buildTypes {
        /*
            可以配置多个buildType项，如下面的release，debug，aabbcc
         */
        release {
            applicationIdSuffix "release"  //add suffix.  <manifest><package="xx.xx.release" >
            versionNameSuffix "_stone" //版本号添加后缀
            minifyEnabled true  //译：使变小enabled。   即启用混淆器
            //混淆文件：sdk/tools/proguard/proguard-android.txt 和 当前module下的proguard-rules.pro
            proguardFiles  getDefaultProguardFile('proguard-android-optimize.txt'),'proguard-rules.pro'
            //getDefaultProguardFile('proguard-android.txt'),
            //getDefaultProguardFile('proguard-android-optimize.txt'),
            signingConfig signingConfigs.myConfig
            zipAlignEnabled true    //混淆后的zip优化，默认为true，可不写。当不显示配置为true时，不会生成unaligned.apk

            applicationVariants.all { variant ->
                variant.outputs.each { output ->
                    if (output.outputFile != null && output.outputFile.name.endsWith('.apk')
                            &&'release'.equals(variant.buildType.name)) {
                        //outputFile 在AS3.0后，没有set方法了，其只有get方法
//                        def apkFile = new File(
//                                output.outputFile.getParent(),
//                                "${appName()}_v${variant.versionName}_${variant.flavorName}_${gitSha()}_${buildTime()}.apk")
//                        output.outputFile = apkFile

                        /*
                        如下结果：当执行gradle sync时(即点击操作栏上的gradle同步按钮)时，
                        且在输出目录有apk情况下，会复制并重命名apk文件
                         */
                        def dir = output.outputFile.getParent()
                        def outDir = "stone/apk"
                        def srcOutPath = output.outputFile.getAbsolutePath()
                        def srcName = srcOutPath.substring(srcOutPath.lastIndexOf(File.separator) + 1)
                        def outName = "${appName()}_v${variant.versionName}_${variant.flavorName}_${gitSha()}_${buildTime()}.apk"
                        buildApkTask(dir, outDir, srcName, outName)
                    }
                }
            }
        }

        debug {//测试发现新版的Gradle不能有多个debuggable 的配置
            debuggable true  //启用debug的buildType配置
            applicationIdSuffix ".debug"
        }

//        aabbcc {
//            multiDexEnabled true
//            applicationIdSuffix ".aabbcc"
//            signingConfig signingConfigs.myConfig
//        }
    }
    productFlavors {
        /*
          productFlavors-产品风格：(AS Gradle 3.0以前)
          		即不同产品的配置，它会基于上面的公共配置项defaultConfig
          		下面的配置项与buildTypes{}中的配置项，成类似sql中的全联(full join)关系
          		 当执行 $gradle build   命令后，会生成：
          		 	module-flavor1-release-unaligned.apk
          		 	module-flavor1-release.apk
          		 	module-flavor1-debug-unaligned.apk
          		 	module-flavor1-debug.apk
          		 	module-flavor1-aabbcc.apk
          		 	...flavor2...apk

          applicationId 用于标识 在谷歌Play商店上的唯一标识 默认不配置，则与app的AndroidManifest.xml中的package一致
          		仅替换<manifest>中的package属性值，其它不受影响

      flavor1 {
            //AS3.0  新增, 只能配置一个 dimension(维度)
            dimension "debug"
            proguardFiles 'proguard-rules.pro'
            applicationId "com.stone.myapplication.pro"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg1",
                                    channelID: "百度应用平台",
                                    test_place_holder: "Stone1"
            ]


            testApplicationId "com.stone.myapplication.test"
            testInstrumentationRunner "android.test.InstrumentationTestRunner"
        }

        flavor2 {
            //AS3.0  新增，  只能配置一个 dimension(维度)
            dimension "release"
            proguardFiles 'proguard-rules.pro'
            applicationId "com.stone.myapplication.free"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg2",
                                    channelID: "豌豆夹",
                                    test_place_holder: "Stone2"
            ]
        }

        flavor3 {
            //AS3.0  新增，  只能配置一个 dimension(维度)
            dimension "aabbcc"
            proguardFiles 'proguard-rules.pro'
            applicationId "com.stone.myapplication.free"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg2",
                                    channelID: "豌豆夹",
                                    test_place_holder: "Stone2"
            ]
        }
        */

        /*
        AS Gradle 3.0:   build variant ==> demoFullDebug  ==> app-demo-full-release/debug.apk
            以前是会生成4个apk的，现在只有两个了。所以这里的 flavors 的配置就不能像以前一样是能各自独立的配置了，
            必须要配置成互补的配置才可以。
            如果还想像以前一样有独立的配置，只能手动注释掉一些flavors了...

         */
        demo {
            dimension "debug"
            applicationId "com.stone.myapplication.pro"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg1",
                                    channelID: "百度应用平台A",
                                    test_place_holder: "Stone1"]
        }

        full {
            dimension "release"
            applicationId "com.stone.myapplication.free"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg2",
                                    channelID: "豌豆夹",
                                    test_place_holder: "Stone2"]
        }
    }


    //concise productFlavors config
//    productFlavors {
//        google{}
//        face{}
//    }
//
//    productFlavors.all {
//        flavor ->
//            //name {google or face}
//            flavor.manifestPlaceholders = [channelID:name, test_place_holder:"stone"]
//
//    }

}
repositories.flatDir { //used for add arr file
    dirs 'libs'
}
dependencies {
    //	Local binary dependency  本地jar包
    api fileTree(include: ['*.jar'], dir: 'libs')
    //Gradle每次编译都会去检查库的更新，使用本地编译生成的库；生成的库文件为 <project-path>/eventbuslib/build/outputs/aar 下的 .arr文件
    api(name: 'eventbuslib-release', ext: 'aar') //  libs/eventbuslib-release.aar
    //    compile project(':eventbuslib') // Module dependency 引用android-library项目
    /*
      Remote binary dependency  download to local   group:name:version
      配置远程仓库中的jar包，打包时，检查本地有没有，若没有则下载到本地。
     */

    api "com.android.support:appcompat-v7:$rootProject.ext.supportVersion"
    api "com.android.support:support-v4:$rootProject.ext.supportVersion"
    api "com.android.support:cardview-v7:$rootProject.ext.supportVersion"
    api "com.android.support:recyclerview-v7:$rootProject.ext.supportVersion"
    //指定某产品，编译依赖的android-library 及 buildType
    /*
                flavor1Compile project(path: ':lib1', configuration: 'flavor1Release')
                flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')
            */
    api 'com.android.support:multidex:1.0.2' //multidex
}

def buildApkTask(inDirPath, outPath, srcName, outName) {
    println("stone---stone")
    println(inDirPath)
    println(outPath)
    println(srcName)
    println(outName)
    tasks.create(name:'copyApks', type:Copy) {
        copy {
            from(inDirPath)
            into(outPath)
            include(srcName)
            rename(srcName, outName)
        }
    }
}
