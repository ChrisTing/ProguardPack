apply plugin: 'com.android.application'
/*
定义一个方法，仅def声明时，返回类型任意(自动判断)
   可以将返回值直接写成String 或def String
gradle支持groovy语言，groovy默认引入的包有：
  java.io.*;
  java.lang.*;
  java.math.BigDecimal;
  java.math.BigInteger;
  java.net.*;
  java.util.*;
  groovy.lang.*;
  groovy.util.*;
 */

def appName() {
    return "ProguardPack"
}

def String vName() {
    return "1.1"
}

def buildTime() {
//    return new Date().format("yyyy-MM-dd", TimeZone.getTimeZone("UTC"));
    return new Date().format('MMdd', TimeZone.getTimeZone('GMT+08:00'))
}

//获取项目最新一次git commit的SHA值,记得要把git要作为环境变量
//def gitSha = 'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim() //git-v2.12 not support
def gitSha() {//git-v2.12 support
    'git rev-parse --short HEAD'.execute([], project.rootDir).text.trim()
}

/*
Build Tasks:
    General Tasks:
        assemble
        The task to assemble the output(s) of the project 用于输出build目录  输出的apk文件为buildType和productflavor的组合体
            还可以使用 assembleBuildType,如$gradle assembleAabbcc 只执行这一个buildType的输出
        check
        The task to run all the checks.  运行检测，会执行test任务
        build
        This task does both assemble and check 包含assemble和check task
        clean
        This task cleans the output of the project 清除输出的build目录
 */




android {
//    compileSdkVersion 22
//    buildToolsVersion "22.0.1"
    compileSdkVersion rootProject.ext.compileSdkVersion  //使用project>build.gradle#ext
    buildToolsVersion rootProject.ext.buildToolsVersion

    lintOptions {
        abortOnError false  //lint 错误是否要中断运行
    }

    dexOptions {//https://developer.android.google.cn/studio/run/index.html
        maxProcessCount 4 // this is the default value
        javaMaxHeapSize "1g"
    }

    sourceSets {
        main {
            java {
                srcDir 'src/full/java'
                //if comment up  ==>  default: src/main/java
            } // <==> java.srcDirs = ['src/full/java']
//            resources {
//                srcDir ['src/full/res', 'src/main/res']
//                //if comment up  ==>  default: src/main/res
//            }
            res.srcDirs = ['src/full/res', 'src/main/res']

            manifest.srcFile 'src/full/AndroidManifest.xml' //只有一个选项值，可以不用 =[] 这样的组形式
        }


//        main.jniLibs {//注意DSL中，property可以用圆点，method可以用 {}
//            srcDir('libs')
//        } //所以可以写成  main {jniLibs{srcDir()}} 或 main.jniLibs.srcDir()
//        main.jniLibs.srcDir('libs')
        //若有多个目录  jniLibs.srcDirs=['libs', 'x86libs']

        androidTest {
            setRoot 'src/androidTest'
        }

    }

    defaultConfig {
        applicationId "com.stone.myapplication"
        minSdkVersion rootProject.ext.minSdkVersion
        targetSdkVersion rootProject.ext.targetSdkVersion
        //versionCode 是一个int值，区间为[0,99999] 一般用于判断app升级
        versionCode 1
        //versionName 是一个字符串，可以展示给用户
        versionName vName() //使用外部定义的方法
        /*
        manifestPlaceholders 
        	manifest中使用占位符，如：<... android:name="${YOUR_APP_KEY}" >
        	以[key-value]形式替换：[YOUR_APP_KEY:"value"]
        */
        manifestPlaceholders = [YOUR_APP_KEY: "后台的appkey"]
        // Enabling multidex support.  method count > 65536    可能还需要其他的操作，现在的新版可能不用(自行试验)
        multiDexEnabled true

        //AS3.0  新增； 凡声明的 dimension 都必须被应用
        flavorDimensions "DimenA", "DimenB"//, "aabbcc"

    }
    defaultConfig.manifestPlaceholders = [YOUR_APP_KEY: "后台的appkey-hoho"]  //reset

    signingConfigs { //gradle assembleRelease
        /*
           可以定义多个签名配置项，如下面的myConfig
         */
        myConfig {
            storeFile file("stone.keystore")
            storePassword "482935"   //修改成自己的签名文件store密码
//			storePassword System.console().readLine("\nKeystore password: ")  //使用命令行gradle build 编译
            keyAlias "stone"
            keyPassword "482935"  //修改成自己的签名文件key密码
//			keyPassword System.console().readLine("\nKey password: ") //使用命令行gradle build 编译
        }
    }

    productFlavors {
        /*s*/

        /*
        3.0 之前：flavors和buildTypes的子项 会多对多匹配；即会有 m x n 个build variant
        3.0 之后：flavors中需要配置dimension， 其又声明在flavorDimensions里面；
                匹配规则是：不同dimension的flavor会被联合，然后与buildTypes的每项匹配；
                这里就会组合成：
                    demoXxxDebug
                    demoXxxRelease
                    demoXxxStaging
                    fullXxxDebug
                    fullXxxRelease
                    fullXxxStaging

         */
        demo {
            dimension "DimenA"
            applicationId "com.stone.myapplication.pro"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg1",
                                    channelID: "百度应用平台A",
                                    test_place_holder: "Stone1"]
        }

        full {
            dimension "DimenA"
            applicationId "com.stone.myapplication.free"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg2",
                                    channelID: "豌豆夹",
                                    test_place_holder: "Stone2"]
        }

        xxx {
            dimension "DimenB"
            applicationId "com.stone.myapplication.xxx"
            manifestPlaceholders = [YOUR_APP_KEY: "abcdefg3",
                                    channelID: "豌豆夹",
                                    test_place_holder: "Stone3"]
        }
    }

    buildTypes {
        /*
            可以配置多个buildType项，如下面的release，debug，aabbcc
         */
        release {
            applicationIdSuffix "release"  //add suffix.  <manifest><package="xx.xx.release" >
            versionNameSuffix "_stone" //版本号添加后缀
            minifyEnabled true  //译：使变小enabled。   即启用混淆器
            //混淆文件：sdk/tools/proguard/proguard-android.txt 和 当前module下的proguard-rules.pro
            proguardFiles  getDefaultProguardFile('proguard-android-optimize.txt'),'proguard-rules.pro'
            //getDefaultProguardFile('proguard-android.txt'),
            //getDefaultProguardFile('proguard-android-optimize.txt'),
            signingConfig signingConfigs.myConfig
            zipAlignEnabled true    //混淆后的zip优化，默认为true，可不写。当不显示配置为true时，不会生成unaligned.apk

            applicationVariants.all { variant ->
                variant.outputs.each { output ->
                    if (output.outputFile != null && output.outputFile.name.endsWith('.apk')
                            &&'release'.equals(variant.buildType.name)) {
                        //outputFile 在AS3.0后，没有set方法了，其只有get方法
//                        def apkFile = new File(
//                                output.outputFile.getParent(),
//                                "${appName()}_v${variant.versionName}_${variant.flavorName}_${gitSha()}_${buildTime()}.apk")
//                        output.outputFile = apkFile

                        /*
                        如下结果：当执行gradle sync时(即点击操作栏上的gradle同步按钮)时，
                        且在输出目录有apk情况下，会复制并重命名apk文件
                        是因为3.0后，each() 要求对象是已存在的
                         */
//                        def dir = output.outputFile.getParent()
//                        def outDir = "stone/apk"
//                        def srcOutPath = output.outputFile.getAbsolutePath()
//                        def srcName = srcOutPath.substring(srcOutPath.lastIndexOf(File.separator) + 1)
//                        def outName = "${appName()}_v${variant.versionName}_${variant.flavorName}_${gitSha()}_${buildTime()}.apk"
//                        buildApkTask(dir, outDir, srcName, outName)

                    }
                }
                //https://developer.android.google.cn/studio/build/gradle-plugin-3-0-0-migration.html#variant_aware
                variant.outputs.all {
                    outputFileName = "${appName()}_v${variant.versionName}_${variant.flavorName}_${gitSha()}_${buildTime()}.apk"
                }

            }
        }

        debug {//测试发现新版的Gradle不能有多个ebuggable 的配置
            debuggable true  //启用debug的buildType配置
            applicationIdSuffix ".debug"
        }

//        aabbcc {
//            multiDexEnabled true
//            applicationIdSuffix ".aabbcc"
//            signingConfig signingConfigs.myConfig
//        }

        staging {
            matchingFallbacks = ['debug', 'aa', 'release']//?
        }

    }

    //concise productFlavors config
//    productFlavors {
//        google{}
//        face{}
//    }
//
//    productFlavors.all {
//        flavor ->
//            //name {google or face}
//            flavor.manifestPlaceholders = [channelID:name, test_place_holder:"stone"]
//
//    }

}
repositories.flatDir { //used for add arr file
    dirs 'libs'
}
dependencies {
    //	Local binary dependency  本地jar包
    api fileTree(include: ['*.jar'], dir: 'libs')
    //Gradle每次编译都会去检查库的更新，使用本地编译生成的库；生成的库文件为 <project-path>/eventbuslib/build/outputs/aar 下的 .arr文件
    api(name: 'eventbuslib-release', ext: 'aar') //  libs/eventbuslib-release.aar
    //    compile project(':eventbuslib') // Module dependency 引用android-library项目
    /*
      Remote binary dependency  download to local   group:name:version
      配置远程仓库中的jar包，打包时，检查本地有没有，若没有则下载到本地。
     */

    api "com.android.support:appcompat-v7:$rootProject.ext.supportVersion"
    api "com.android.support:support-v4:$rootProject.ext.supportVersion"
    api "com.android.support:cardview-v7:$rootProject.ext.supportVersion"
    api "com.android.support:recyclerview-v7:$rootProject.ext.supportVersion"
    //指定某产品，编译依赖的android-library 及 buildType
    /*
                flavor1Compile project(path: ':lib1', configuration: 'flavor1Release')
                flavor2Compile project(path: ':lib1', configuration: 'flavor2Release')
            */
    api 'com.android.support:multidex:1.0.2' //multidex
}

def buildApkTask(inDirPath, outPath, srcName, outName) {
    println("stone---stone")
    println(inDirPath)
    println(outPath)
    println(srcName)
    println(outName)
    tasks.create(name:'copyApk', type:Copy) {
        copy {
            from(inDirPath)
            into(outPath)
            include(srcName)
            rename(srcName, outName)
        }
    }
}
